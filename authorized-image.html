<!doctype html>
<link rel="import" href="../../bower_components/iron-image/iron-image.html">
<link rel="import" href="../../bower_components/polymer/polymer-element.html">
<link rel="import" href="authorized-fetch-mixin.html">

<dom-module id="authorized-image">
	<template>
		<style>
		/* Fit this component into the the parent */
		:host {
			display: inline-block;
			overflow: hidden;
			position: relative;
		}

		/* Fit the image into this space */
		iron-image {
			width: 100%;
			height: 100%;
			vertical-align: top;
		}
		</style>
		<iron-image
			id="image"

			alt="{{alt}}"
			crossorigin="{{crossorigin}}"
			error="{{_ironImageError}}"
			fade="{{fade}}"
			height="{{height}}"
			loaded="{{loaded}}"
			loading="{{loading}}"
			placeholder="[[_computePlaceholder(src, placeholder)]]"
			position="{{position}}"
			preload="{{preload}}"
			prevent-load="[[_computePreventLoad(preventLoad, _displayed)]]"
			sizing="{{sizing}}"
			src="[[_computeSrc(src, _wasVisible, _displayed, token)]]"
			width="{{width}}"
		></iron-image>
	</template>

	<script>
		/**
		 * Image that uses the file-token to authenticate requests to images
		 *
		 * @customElement
		 * @polymer
		 */
		class AuthorizedImage extends
			Collaborne.AuthorizedFetchMixin(
			Polymer.Element) {

			static get is() {
				return 'authorized-image';
			}

			static get properties() {
				return {
					_displayed: Object,
					_ironImageError: Boolean,
					/**
					 * Whether this image was ever visible.
					 * This property is used to delay the internal "fetch" request for invisible images, but avoid
					 * extra _computeSrc calls when this image is hidden after it was visible once.
					 */
					_wasVisible: {
						computed: '_computeWasVisible(_wasVisible, _supportsIntersectionObserver, _visible)'
					},
					_supportsIntersectionObserver: {
						value: typeof IntersectionObserver === 'function',
						readOnly: true,
						type: Boolean,
					},

					alt: String,
					crossorigin: String,
					error: {
						computed: '_computeError(_ironImageError, _displayed)',
						notify: true,
						readOnly: true,
						reflectToAttribute: true,
						type: Boolean,
					},
					fade: Boolean,
					height: Number,
					loaded: {
						notify: true,
						readOnly: true,
						type: Boolean,
					},
					loading: {
						notify: true,
						readOnly: true,
						type: Boolean,
					},
					placeholder: String,
					position: String,
					preload: Boolean,
					preventLoad: Boolean,
					sizing: String,
					src: String,
					width: Number,

					token: String,
					mode: {
						value: 'cors',
						type: String,
					},
				};
			}

			ready() {
				super.ready();

				// Register an "intersection observer" to learn when this element is actually becoming
				// visible.
				// If the browser doesn't support this functionality we rely on the default value.
				// Observe mutations to the parent element that affect us
				if (this._supportsIntersectionObserver) {
					this._observer = new IntersectionObserver(entries => {
						// See https://stackoverflow.com/a/38873788/196315
						// XXX: Can we instead look at the entries, specifically 'isIntersecting'?
						this._visible = !!(this.offsetHeight || this.offsetWidth || this.getClientRects().length > 0);
					});
					this._observer.observe(this);
				}
			}

			_computeWasVisible(wasVisible, supportsIntersectionObserver, visible) {
				// If the element was visible before do no longer change.
				if (wasVisible) {
					return wasVisible;
				}

				// If the browser does not support intersection observers assume the element is
				// visible.
				if (!supportsIntersectionObserver) {
					return true;
				}

				// Otherwise: Check the property that will be set by the intersection observer.
				return visible;
			}

			_computeError(ironImageError, displayed) {
				return Boolean(ironImageError || displayed && displayed.dataUrl === '');
			}

			_computeSrc(src, wasVisible, displayed, token) {
				// Use the existing data if we already have some.
				// Note that when there was an error fetching the data because the token was missing,
				// this would prevent a reload, so explicitly check for that.
				if (displayed) {
					const forceReload = displayed.dataUrl === '' && token;
					if (!forceReload && src === displayed.src) {
						return displayed.dataUrl;
					}
				}

				// Return '', which iron-image treats as "nothing to do"
				let result = '';

				if (src && wasVisible) {
					// Set base to support relative URLs
					const srcUrl = new URL(src, window.location);
					if (srcUrl.protocol === 'data:') {
						// Data URL, we can use that directly.
						this._displayed = this.displayed(src, src);
						result = src;
					} else {
						// Starting fetching content
						this.fetchDataUrl(src, token).then(result => this._displayed = result);
					}
				}

				return result;
			}

			_computePreventLoad(preventLoad, displayed) {
				// Prevent loading when either the user requested that, or when we cannot actually display things.
				return preventLoad || (displayed && displayed.dataUrl === '');
			}

			_computePlaceholder(src, placeholder) {
				// Only use the placeholder when we do not have a src at all
				if (!src) {
					return placeholder;
				}
			}
		}
		window.customElements.define(AuthorizedImage.is, AuthorizedImage);
	</script>
</dom-module>
